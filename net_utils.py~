from __future__ import absolute_import, division, print_function

import matplotlib as mpl
import numpy as np
import keras
import os, tempfile, sys, glob, h5py
from keras.utils import HDF5Matrix
from keras.models import Sequential, Model, load_model
from keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Dropout, Conv2D, MaxPooling2D, BatchNormalization, Input, GaussianNoise, concatenate
from keras.layers.normalization import BatchNormalization
from keras.layers.convolutional import AveragePooling2D
from keras.layers.core import Activation, Dropout
from keras import backend as K
import tensorflow as tf
from keras.backend.tensorflow_backend import set_session
from keras.utils import plot_model
import matplotlib.pyplot as plt 
from sklearn.preprocessing import StandardScaler
from keras.callbacks import EarlyStopping
from keras import regularizers
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy.ma as ma
from  matplotlib.pyplot import cm
from sklearn.preprocessing import scale
from mlxtend.evaluate import confusion_matrix
from mlxtend.plotting import plot_confusion_matrix
from keras.metrics import binary_accuracy
from deepexplain.tensorflow import DeepExplain
#from ctapipe.image import tailcuts_clean
from picturekiller import add_noise,add_star,add_bad_flatfield
from sklearn.metrics import roc_curve, auc
from sklearn.preprocessing import label_binarize
from scipy import interp
from itertools import cycle

modelFile='/home/spencers/scripts/refiner_model_step_9900.h5'

def self_regularization_loss(y_true, y_pred):
    delta = 0.000001  # FIXME: need to figure out an appropriate value for this
    return tf.multiply(delta, tf.reduce_sum(tf.abs(y_pred - y_true)))

global gan_refiner
gan_refiner = load_model(modelFile,custom_objects={'self_regularization_loss':self_regularization_loss})
gan_refiner._make_predict_function()
global trainevents
trainevents = []
global validevents
validevents = []
global testevents
testevents = []
global train2
train2 = []
global test2
test2 = []
global valid2
valid2 = []

def nice_imshow(ax, data, vmin=None, vmax=None, cmap=None):
    """Wrapper around pl.imshow"""
    if cmap is None:
        cmap = cm.jet
    if vmin is None:
        vmin = data.min()
    if vmax is None:
        vmax = data.max()
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    im = ax.imshow(data, vmin=vmin, vmax=vmax, interpolation='nearest', cmap=cmap)
    plt.colorbar(im, cax=cax)

def make_mosaic(nimgs,imgs, nrows, ncols, border=1):
    """
    Given a set of images with all the same shape, makes a
    mosaic with nrows and ncols
    """
    imshape = imgs.shape[:2]
    print(nimgs,imshape,nrows,ncols)
    mosaic = ma.masked_all((nrows * imshape[0] + (nrows - 1) * border,
                            ncols * imshape[1] + (ncols - 1) * border),
                            dtype=np.float32)
    
    paddedh = imshape[0] + border
    paddedw = imshape[1] + border
    for i in range(nimgs):
        row = int(np.floor(i / ncols))
        col = i % ncols

        mosaic[row * paddedh:row * paddedh + imshape[0],
               col * paddedw:col * paddedw + imshape[1]] = imgs[:,:,i]
    return mosaic

def get_confusion_matrix_one_hot(runname,model_results, truth):
    '''model_results and truth should be for one-hot format, i.e, have >= 2 columns,
    where truth is 0/1, and max along each row of model_results is model result
    '''
    mr=[]
    mr2=[]
    mr3=[]
    for x in model_results:
        mr.append(np.argmax(x))
        mr2.append(x)
    mr3 = label_binarize(mr, classes=[0, 1, 2])
    no_ev=min(len(mr),len(truth))
    print(no_ev)
    model_results=np.asarray(mr)[:no_ev]
    truth=np.asarray(truth)[:no_ev]
    print(np.shape(model_results),np.shape(truth))
    mr2=mr2[:no_ev]
    mr3=mr3[:no_ev]
    cm=confusion_matrix(y_target=truth,y_predicted=np.rint(np.squeeze(model_results)),binary=False)
    fig,ax=plot_confusion_matrix(conf_mat=cm,figsize=(5,5))
    plt.xlabel('Predicted Label')
    plt.ylabel('True Label')
    plt.savefig('/home/spencers/Figures/'+runname+'confmat.png')
    lw=2
    n_classes=3
    fpr = dict()
    tpr = dict()
    roc_auc = dict()
    t2 = label_binarize(truth, classes=[0, 1, 2])
    for i in range(n_classes):
        fpr[i], tpr[i], _ = roc_curve(t2[:, i], np.asarray(mr2)[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    all_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))
    
    # Then interpolate all ROC curves at this points
    mean_tpr = np.zeros_like(all_fpr)
    for i in range(n_classes):
        mean_tpr += interp(all_fpr, fpr[i], tpr[i])

    # Finally average it and compute AUC
    mean_tpr /= n_classes
    
    fpr["macro"] = all_fpr
    tpr["macro"] = mean_tpr
    roc_auc["macro"] = auc(fpr["macro"], tpr["macro"])
    fpr["micro"], tpr["micro"], _ = roc_curve(t2.ravel(), mr3.ravel())
    roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])

    # Plot all ROC curves
    plt.figure()
    plt.plot(fpr["micro"], tpr["micro"],
             label='Micro-average ROC curve (area = {0:0.2f})'
                   ''.format(roc_auc["micro"]),
             color='deeppink', linestyle=':', linewidth=4)

    plt.plot(fpr["macro"], tpr["macro"],
             label='Macro-average ROC curve (area = {0:0.2f})'
                   ''.format(roc_auc["macro"]),
             color='navy', linestyle=':', linewidth=4)

    colors = cycle(['aqua', 'darkorange', 'cornflowerblue'])
    for i, color in zip(range(n_classes), colors):
        plt.plot(fpr[i], tpr[i], color=color, lw=lw,
                 label='ROC curve of class {0} (area = {1:0.2f})'
                 ''.format(i, roc_auc[i]))
    plt.legend(loc="lower right")
    plt.savefig('/home/spencers/Figures/'+runname+'_roc.png')
    np.save('/home/spencers/confmatdata/'+runname+'_fp.npy',fpr)
    np.save('/home/spencers/confmatdata/'+runname+'_tp.npy',tpr)
    return cm

    
def resnet_block(input_features, nb_features=128, nb_kernel_rows=3, nb_kernel_cols=3):
    """
    A ResNet block with two `nb_kernel_rows` x `nb_kernel_cols` convolutional layers,
    each with `nb_features` feature maps.

    See Figure 6 in https://arxiv.org/pdf/1612.07828v1.pdf.

    :param input_features: Input tensor to ResNet block.
    :return: Output tensor from ResNet block.
    """
    y = layers.Convolution2D(nb_features, nb_kernel_rows, nb_kernel_cols, border_mode='same')(input_features)
    y = layers.Activation('relu')(y)
    y = layers.Convolution2D(nb_features, nb_kernel_rows, nb_kernel_cols, border_mode='same')(y)
    y = layers.merge.Add()([input_features, y])
    return layers.Activation('relu')(y)

def generate_training_sequences(onlyfiles,batch_size, batchflag, shilonflag=False):
    """ Generates training/test sequences on demand
    """

    nofiles = 0
    i = 0  # No. events loaded in total

    if batchflag == 'Train':
        filelist = onlyfiles[:140]
        print('train', filelist)
        global trainevents
        global train2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainevents = trainevents + inputdata['event_id'][:].tolist()
            train2 = train2 + inputdata['id'][:].tolist()
            inputdata.close()

    elif batchflag == 'Test':
        filelist = onlyfiles[140:239]
        print('test', filelist)
        global testevents
        global test2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            testevents = testevents + inputdata['event_id'][:].tolist()
            test2 = test2 + inputdata['id'][:].tolist()
            inputdata.close()
    elif batchflag == 'Valid':
        '''filelist = onlyfiles[30:40]
        print('valid', filelist)
        global validevents
        global valid2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            validevents = validevents + inputdata['event_id'][:].tolist()
            valid2 = valid2 + inputdata['id'][:].tolist()
            inputdata.close()'''
    else:
        print('Error: Invalid batchflag')
        raise KeyboardInterrupt

    while True:
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainarr = np.asarray(inputdata['peak_times'][:, :, :, :])
            trainarr = trainarr[:, :, 8:40, 8:40]
            chargearr = np.asarray(inputdata['squared_training'][:, :, :, :])
            chargearr = chargearr[:, :, 8:40, 8:40]
            rtarr = np.asarray(inputdata['RT'][:, :, :, :])
            rtarr = rtarr[:, :, 8:40, 8:40]
            ftarr = np.asarray(inputdata['FT'][:, :, :, :])
            ftarr = ftarr[:, :, 8:40, 8:40]
            fwhmarr = np.asarray(inputdata['FWHM'][:, :, :, :])
            fwhmarr = fwhmarr[:, :, 8:40, 8:40]
            amparr = np.asarray(inputdata['waveform_amplitude'][:, :, :, :])
            amparr = amparr[:, :, 8:40, 8:40]
            meanarr = np.asarray(inputdata['waveform_mean'][:, :, :, :])
            meanarr = meanarr[:, :, 8:40, 8:40]
            rmsarr = np.asarray(inputdata['waveform_rms'][:, :, :, :])
            rmsarr = rmsarr[:, :, 8:40, 8:40]
            labelsarr = np.asarray(inputdata['event_label'][:])
            idarr = np.asarray(inputdata['id'][:])
            nofiles = nofiles + 1
            inputdata.close()
            notrigs=np.shape(trainarr)[0]
            trainarr = np.reshape(trainarr, (notrigs, 4, 32, 32, 1))
            chargearr = np.reshape(chargearr, (notrigs, 4, 32, 32, 1))
            rtarr = np.reshape(rtarr, (notrigs, 4, 32, 32, 1))
            ftarr = np.reshape(ftarr, (notrigs, 4, 32, 32, 1))
            fwhmarr = np.reshape(fwhmarr, (notrigs, 4, 32, 32, 1))
            amparr = np.reshape(amparr, (notrigs, 4, 32, 32, 1))
            meanarr = np.reshape(meanarr, (notrigs, 4, 32, 32, 1))
            rmsarr = np.reshape(rmsarr, (notrigs, 4, 32, 32, 1))
            
            if shilonflag == False:
                for x in np.arange(np.shape(trainarr)[0]):
                    medvals = []
                    for y in np.arange(4):
                        medvals.append(np.median(trainarr[x, y, :, :]))

                    medvals = np.argsort(medvals)
                    trainarr[x, :, :, :] = trainarr[x, medvals, :, :]
                    chargearr[x, :, :, :] = chargearr[x, medvals, :, :]
                    rtarr[x, :, :, :] = rtarr[x, medvals, :, :]
                    ftarr[x, :, :, :] = ftarr[x, medvals, :, :]
                    fwhmarr[x, :, :, :] = fwhmarr[x, medvals, :, :]
                    amparr[x, :, :, :] = amparr[x, medvals, :, :]
                    meanarr[x, :, :, :] = meanarr[x, medvals, :, :]
                    rmsarr[x, :, :, :] = rmsarr[x, medvals, :, :]

            elif shilonflag == True:
                for x in np.arange(np.shape(trainarr)[0]):
                    chargevals = []
                    for y in np.arange(4):
                        chargevals.append(np.sum(chargearr[x,y,:,:]))

                    chargevals = np.argsort(chargevals)
                    chargevals = np.flip(chargevals,axis=0) #Flip to descending order.
                    trainarr[x, :, :, :] = trainarr[x, chargevals, :, :]
                    chargearr[x, :, :, :] = chargearr[x, chargevals, :, :]
                    rtarr[x, :, :, :] = rtarr[x, chargevals, :, :]
                    ftarr[x, :, :, :] = ftarr[x, chargevals, :, :]
                    fwhmarr[x, :, :, :] = fwhmarr[x, chargevals, :, :]
                    amparr[x, :, :, :] = amparr[x, chargevals, :, :]
                    meanarr[x, :, :, :] = meanarr[x, chargevals, :, :]
                    rmsarr[x, :, :, :] = rmsarr[x, chargevals, :, :]
            
            training_sample_count = len(trainarr)
            batches = int(training_sample_count / batch_size)
            remainder_samples = training_sample_count % batch_size
            i = i + 1000
            countarr = np.arange(0, len(labelsarr))
            ta2 = np.zeros((training_sample_count, 4, 32, 32, 1))
            
            #ta2[:, :, :, :, 0] = chargearr[:, :, :, :, 0]
            ta2[:, :, :, :, 0] = trainarr[:, :, :, :, 0]
            #ta2[:, :, :, :, 2] = rtarr[:, :, :, :, 0]
            #ta2[:, :, :, :, 3] = ftarr[:, :, :, :, 0]
            #ta2[:, :, :, :, 4] = fwhmarr[:, :, :, :, 0]
            #ta2[:, :, :, :, 5] = amparr[:, :, :, :, 0]
            #ta2[:, :, :, :, 6] = meanarr[:, :, :, :, 0]
            #ta2[:, :, :, :, 7] = rmsarr[:, :, :, :, 0]

            trainarr = ta2
            trainarr = (trainarr-np.amin(trainarr,axis=0))/(np.amax(trainarr,axis=0)-np.amin(trainarr,axis=0))
            if remainder_samples:
                batches = batches + 1

            # generate batches of samples
            for idx in list(range(0, batches)):
                if idx == batches - 1:
                    batch_idxs = countarr[idx * batch_size:]
                else:
                    batch_idxs = countarr[idx *
                                          batch_size:idx *
                                          batch_size +
                                          batch_size]
                X = trainarr[batch_idxs]
                X = np.nan_to_num(X)
                Y = keras.utils.to_categorical(
                    labelsarr[batch_idxs], num_classes=3)
                yield (np.array(X), np.array(Y))

def generate_training_sequences2d(onlyfiles,batch_size, batchflag, shilonflag=False):
    """ Generates training/test sequences on demand
    """

    nofiles = 0
    i = 0  # No. events loaded in total

    if batchflag == 'Train':
        filelist = onlyfiles[:160]
        global trainevents
        global train2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainevents = trainevents + inputdata['event_id'][:].tolist()
            train2 = train2 + inputdata['id'][:].tolist()
            inputdata.close()

    elif batchflag == 'Test':
        filelist = onlyfiles[160:320]
        global testevents
        global test2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            testevents = testevents + inputdata['event_id'][:].tolist()
            test2 = test2 + inputdata['id'][:].tolist()
            inputdata.close()
    else:
        print('Error: Invalid batchflag')
        raise KeyboardInterrupt

    while True:
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            chargearr = np.asarray(inputdata['squared_training'][:, 0, :, :])
            chargearr = chargearr[:,8:40, 8:40]
            labelsarr = np.asarray(inputdata['labels'][:,0])
            valilocs = np.where(labelsarr!=-1)[0]
            labelsarr = labelsarr[valilocs]
            chargearr = chargearr[valilocs,:,:]
            idarr = np.asarray(inputdata['id'][:])
            nofiles = nofiles + 1
            inputdata.close()
            chargearr = np.reshape(chargearr, (np.shape(chargearr)[0], 32, 32, 1))
            
            training_sample_count = len(chargearr)
            batches = int(training_sample_count / batch_size)
            remainder_samples = training_sample_count % batch_size
            i = i + 1000
            countarr = np.arange(0, len(labelsarr))
            ta2 = np.zeros((training_sample_count, 32, 32, 1))
            
            ta2[:, :, :, 0] = chargearr[:, :, :, 0]

            trainarr = ta2
            trainarr = (trainarr-np.amin(trainarr,axis=0))/(np.amax(trainarr,axis=0)-np.amin(trainarr,axis=0))

            if remainder_samples:
                batches = batches + 1

            # generate batches of samples
            for idx in list(range(0, batches)):
                if idx == batches - 1:
                    batch_idxs = countarr[idx * batch_size:]
                else:
                    batch_idxs = countarr[idx *
                                          batch_size:idx *
                                          batch_size +
                                          batch_size]
                X = trainarr[batch_idxs]
                X = np.nan_to_num(X)
                Y = keras.utils.to_categorical(
                    labelsarr[batch_idxs], num_classes=3)
                yield (np.array(X), np.array(Y))

def generate_corrupt_training_sequences(onlyfiles,batch_size, batchflag, shilonflag=False, plotbad=False):
    """ Generates training/test sequences on demand
    """

    nofiles = 0
    i = 0  # No. events loaded in total

    if batchflag == 'Train':
        filelist = onlyfiles[:320]
        print('train', filelist)
        global trainevents
        global train2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainevents = trainevents + inputdata['event_id'][:].tolist()
            train2 = train2 + inputdata['id'][:].tolist()
            inputdata.close()

    elif batchflag == 'Test':
        filelist = onlyfiles[320:640]
        print('test', filelist)
        global testevents
        global test2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            testevents = testevents + inputdata['event_id'][:].tolist()
            test2 = test2 + inputdata['id'][:].tolist()
            inputdata.close()
    else:
        print('Error: Invalid batchflag')
        raise KeyboardInterrupt

    while True:
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            chargearr = np.asarray(inputdata['squared_training'][:, :, :, :])
            chargearr = chargearr[:, 0, 8:40, 8:40]
            labelsarr = np.asarray(inputdata['event_label'][:])
            idarr = np.asarray(inputdata['id'][:])
            nofiles = nofiles + 1
            inputdata.close()
            chargearr = np.reshape(chargearr, (200,32, 32, 1))
            training_sample_count = len(chargearr)
            batches = int(training_sample_count / batch_size)
            remainder_samples = training_sample_count % batch_size
            i = i + 1000
            countarr = np.arange(0, len(labelsarr))
            ta2 = np.zeros((training_sample_count,32, 32, 1))
            
            ta2[:, :, :, 0] = chargearr[:, :, :, 0]

            trainarr = ta2
            trainarr = (trainarr-np.amin(trainarr,axis=0))/(np.amax(trainarr,axis=0)-np.amin(trainarr,axis=0))

            randnum = np.random.randint(0,4)

            if randnum==0:
                plottitle='No Modification'
            if randnum==1:
                dev=np.random.uniform(0,np.amax(trainarr))
                trainarr=add_noise(trainarr,dev,200)
                plottitle='Gaussian Noise Added, \n stddev='+str(dev)
            if randnum==2:
                trainarr=add_star(trainarr,200)
                plottitle='Star Added'
            if randnum==3:
                trainarr=add_bad_flatfield(trainarr,200)
                plottitle='Bad Flat Field Added'

            if remainder_samples:
                batches = batches + 1

            # generate batches of samples
            for idx in list(range(0, batches)):
                if idx == batches - 1:
                    batch_idxs = countarr[idx * batch_size:]
                else:
                    batch_idxs = countarr[idx *
                                          batch_size:idx *
                                          batch_size +
                                          batch_size]
                X = trainarr[batch_idxs]
                X = np.nan_to_num(X)
                Y = keras.utils.to_categorical(
                    labelsarr[batch_idxs], num_classes=2)
                yield (np.array(X), np.array(Y))


def generate_corrupt_training_sequences2d(onlyfiles,batch_size, batchflag, shilonflag=False, plotbad=False):
    """ Generates training/test sequences on demand
    """

    nofiles = 0
    i = 0  # No. events loaded in total

    if batchflag == 'Train':
        filelist = onlyfiles[:160]
        global trainevents
        global train2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainevents = trainevents + inputdata['event_id'][:].tolist()
            train2 = train2 + inputdata['id'][:].tolist()
            inputdata.close()

    elif batchflag == 'Test':
        filelist = onlyfiles[160:320]
        global testevents
        global test2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            testevents = testevents + inputdata['event_id'][:].tolist()
            test2 = test2 + inputdata['id'][:].tolist()
            inputdata.close()
    else:
        print('Error: Invalid batchflag')
        raise KeyboardInterrupt

    while True:
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            chargearr = np.asarray(inputdata['squared_training'][:, 0, :, :])
            chargearr = chargearr[:, 8:40, 8:40]
            labelsarr = np.asarray(inputdata['labels'][:,0])
            valilocs = np.where(labelsarr!=-1)[0]
            labelsarr = labelsarr[valilocs]
            chargearr = chargearr[valilocs,:,:]
            idarr = np.asarray(inputdata['id'][:])
            nofiles = nofiles + 1
            inputdata.close()
            chargearr = np.reshape(chargearr, (np.shape(chargearr)[0], 32, 32, 1))
            training_sample_count = len(chargearr)
            batches = int(training_sample_count / batch_size)
            remainder_samples = training_sample_count % batch_size
            i = i + 1000
            countarr = np.arange(0, len(labelsarr))
            ta2 = np.zeros((training_sample_count, 32, 32, 1))
            
            ta2[:,:, :, 0] = chargearr[:,:, :,0]

            trainarr = ta2
            trainarr = (trainarr-np.amin(trainarr,axis=0))/(np.amax(trainarr,axis=0)-np.amin(trainarr,axis=0))

            orig = trainarr[0,:,:,0].copy()
            randnum = np.random.randint(0,4)

            if randnum==0:
                plottitle='No Modification'
            if randnum==1:
                dev=np.random.uniform(0,np.amax(trainarr))
                trainarr=add_noise(trainarr,dev,200)
                plottitle='Gaussian Noise Added, \n stddev='+str(dev)
            if randnum==2:
                trainarr=add_star(trainarr,200)
                plottitle='Star Added'
            if randnum==3:
                trainarr=add_bad_flatfield(trainarr,200)
                plottitle='Bad Flat Field Added'
            if plotbad==True:
                plt.subplot(1,2,1)
                plt.imshow(orig)
                plt.colorbar()
                plt.title('Original')
                plt.subplot(1,2,2)
                plt.imshow(trainarr[0,0,:,:,0])
                plt.colorbar()
                plt.title(plottitle)
                plt.tight_layout()
                plt.savefig(str(randnum)+'corrupted.png')
                raise KeyboardInterrupt

            if remainder_samples:
                batches = batches + 1

            # generate batches of samples
            for idx in list(range(0, batches)):
                if idx == batches - 1:
                    batch_idxs = countarr[idx * batch_size:]
                else:
                    batch_idxs = countarr[idx *
                                          batch_size:idx *
                                          batch_size +
                                          batch_size]
                X = trainarr[batch_idxs]
                X = np.nan_to_num(X)
                Y = keras.utils.to_categorical(
                    labelsarr[batch_idxs], num_classes=2)
                yield (np.array(X), np.array(Y))

def gen1(onlyfiles,batchflag):
    yield(generate_training_sequences2d(onlyfiles,50,batchflag))

def gen2(onlyfiles,batchflag):
    yield(generate_corrupt_training_sequences2d(onlyfiles,50,batchflag))

def gen3(onlyfiles,batch_size,batchflag):
    nofiles = 0
    i = 0  # No. events loaded in total

    if batchflag == 'Train':
        filelist = onlyfiles[:160]
        global trainevents
        global train2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            trainevents = trainevents + inputdata['event_id'][:].tolist()
            train2 = train2 + inputdata['id'][:].tolist()
            inputdata.close()

    elif batchflag == 'Test':
        filelist = onlyfiles[160:320]
        global testevents
        global test2
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            testevents = testevents + inputdata['event_id'][:].tolist()
            test2 = test2 + inputdata['id'][:].tolist()
            inputdata.close()
    else:
        print('Error: Invalid batchflag')
        raise KeyboardInterrupt

    while True:
        for file in filelist:
            inputdata = h5py.File(file, 'r')
            chargearr = np.asarray(inputdata['squared_training'][:, 0, :, :])
            chargearr = chargearr[:,8:40, 8:40]
            labelsarr = np.asarray(inputdata['labels'][:,0])
            valilocs = np.where(labelsarr!=-1)
            labelsarr = labelsarr[valilocs]
            chargearr = chargearr[valilocs,:,:]
            idarr = np.asarray(inputdata['id'][:])
            nofiles = nofiles + 1
            inputdata.close()
            chargearr = np.reshape(chargearr, (np.shape(chargearr)[0], 32, 32, 1))
            
            training_sample_count = len(chargearr)
            batches = int(training_sample_count / batch_size)
            remainder_samples = training_sample_count % batch_size
            i = i + 1000
            countarr = np.arange(0, len(labelsarr))
            ta2 = np.zeros((training_sample_count, 32, 32, 1))
            
            ta2[:, :, :, 0] = chargearr[:, :, :, 0]

            trainarr = ta2
            trainarr = (trainarr-np.amin(trainarr,axis=0))/(np.amax(trainarr,axis=0)-np.amin(trainarr,axis=0))

            if remainder_samples:
                batches = batches + 1

            # generate batches of samples
            for idx in list(range(0, batches)):
                if idx == batches - 1:
                    batch_idxs = countarr[idx * batch_size:]
                else:
                    batch_idxs = countarr[idx *
                                          batch_size:idx *
                                          batch_size +
                                          batch_size]
                X = trainarr[batch_idxs]
                X = np.nan_to_num(X)
                Y = keras.utils.to_categorical(
                    labelsarr[batch_idxs], num_classes=2)
                X = np.array(X)
                X=gan_refiner.predict(X,steps=1,verbose=0)
                yield (X, np.array(Y))
